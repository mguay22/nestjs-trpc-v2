---
title: "Middlewares"
---

# Middlewares

With this adapter you can create procedure middlewares,
These middlewares can be added to a router class, either globally for all procedures in that router or individually to specific procedures using the `@UseMiddlewares()` decorator.

The `@UseMiddlewares()` decorator accepts multiple middlewares, executing them in the provided order. For instance:
```ts
@UseMiddlewares(LoggingMiddleware, AuthMiddleware)
```
In this example, `LoggingMiddleware` runs first, followed by `AuthMiddleware`.

If both the router and the procedure have middlewares defined via `@UseMiddlewares()`, the router-level middlewares will execute first, followed by the procedure-level middlewares, provided there are no duplicates.

This middleware approach in tRPC is similar to the `Guards` and `Middlewares` concept found in NestJS.

<Callout>
  If you are not sure about the basic **concepts** of NestJS or tRPC middlewares, you can dive into those concepts in their official documentation.
</Callout>

<Cards>
  <Card title="What are NestJS Middlewares" href="https://docs.nestjs.com/middleware" />
  <Card title="What are tRPC Middlewares" href="https://trpc.io/docs/server/middlewares" />
</Cards>

<Steps>
<Step>
### Creating a Middleware
You can implement a middleware in a class with an `@Injectable()` decorator. The class should implement the `TRPCMiddleware` interface.
Let's start by implementing a simple logger middleware.

<Tabs items={["NestJS Adapter Middleware", "tRPC Middleware"]}>
  <Tab value="NestJS Adapter Middleware">
    ```typescript title="logger.middleware.ts"
    import { TRPCMiddleware, TRPCMiddlewareOptions } from 'nestjs-trpc-v2';
    import { Inject, Injectable, ConsoleLogger } from '@nestjs/common';
    import type { Context } from "nestjs-trpc-v2/types";

    @Injectable()
    export class LoggedMiddleware implements TRPCMiddleware<Context> {

      constructror(
        @Inject(ConsoleLogger) private readonly consoleLogger: ConsoleLogger
      ) {}

      use(opts: TRPCMiddlewareOptions) {
        const start = Date.now();
        const { next, path, type } = opts;
        const result = await next();

        const durationMs = Date.now() - start;
        const meta = { path, type, durationMs }

        result.ok
          ? this.consoleLogger.log('OK request timing:', meta)
          : this.consoleLogger.error('Non-OK request timing', meta);

        return result;
      }
    }
    ```
  </Tab>
  <Tab value="tRPC Middleware">
    ```typescript title="server.ts"
    export const loggedProcedure = publicProcedure.use(async (opts) => {
      const start = Date.now();

      const result = await opts.next();

      const durationMs = Date.now() - start;
      const meta = { path: opts.path, type: opts.type, durationMs };

      result.ok
        ? console.log('OK request timing:', meta)
        : console.error('Non-OK request timing', meta);

      return result;
    });
    ```
  </Tab>
</Tabs>
</Step>

<Step>
### Middleware registration
Similar to NestJS providers, we need to register the middleware with Nest so that it can perform the injection and type generation.
We do this by editing our module file and adding the middleware to the `providers` array of the `@Module()` decorator.
</Step>

<Step>
### Applying middleware
To use the middleware in your procedure instead of the default `publicProcedure`, pass the class to the `@UseMiddlewares()` method decorator.
```typescript title="dogs.router.ts"
import { DatabaseService } from "./database.service.ts";
import { LoggedMiddleware } from "./logged.middleware.ts";
import { AuthMiddleware } from "./auth.middleware.ts";
import { Router, Query, UseMiddlewares } from 'nestjs-trpc-v2';
import { Inject } from '@nestjs/common';
import { z } from 'zod';

const dogsSchema = z.object({
  name: z.string(),
  breed: z.enum(["Labrador", "Corgi", "Beagle", "Golden Retriver"])
});

@Router()
export class DogsRouter {
  constructor(@Inject(DatabaseService) private databaseService: DatabaseService){}

  @UseMiddlewares(LoggedMiddleware, AuthMiddleware)
  @Query({ output: z.array(dogSchema) })
  async findAll(): string {
    const dogs = await this.databaseService.dogs.findMany();
    return dogs;
  }
}
```
</Step>
</Steps>


#### Modified Context
With middlewares you can change and inject certain parameters in the context to be available to the procedure, this can be done by using the `next(){:tsx}` method available from the `opts` parameter.

##### Generated Context
When you modify the base context with a middleware, a new type will be generated with the middleware name and a `Context` suffix, for example if you have an `AuthMiddleware`, the generated type would be named `AuthMiddlewareContext`.

Then you can import those types and use throughout your procedures from `nestjs-trpc-v2/types`, for example:
<Tabs items={["User Router", "Auth Middleware", "Generated Interface"]}>
  <Tab value="User Router">
```typescript title="user.router.ts"
import type { AuthMiddlewareContext } from 'nestjs-trpc-v2/types';
import { UserService } from "./user.service.ts";
import { AuthMiddleware } from "./auth.middleware.ts";
import { Router, Query, UseMiddlewares } from 'nestjs-trpc-v2';
import { Inject } from '@nestjs/common';
import { z } from 'zod';

const userSchema = z.object({
  name: z.string(),
  email: z.string(),
  avatar: z.string()
});

@Router()
export class UserRouter {
  constructor(@Inject(UserService) private userService: UserService){}

  @UseMiddlewares(AuthMiddleware)
  @Query({ output: userSchema })
  async getUserProfile(@Context() ctx: AuthMiddlewareContext): string {
    const { userId } = ctx.auth;
    return await this.userService.getUserById(userId);
  }
}
```
  </Tab>
  <Tab value="Auth Middleware">
```typescript title="auth.middleware.ts"
import {
  MiddlewareOptions,
  MiddlewareResponse,
  TRPCMiddleware,
} from 'nestjs-trpc-v2';
import { Inject, Injectable } from '@nestjs/common';
import { AuthService } from './auth.service';
import { TRPCError } from '@trpc/server';
import type { Context } from 'nestjs-trpc-v2/types';

@Injectable()
export class AuthMiddleware implements TRPCMiddleware {
  constructor(@Inject(AuthService) private readonly authService: AuthService) {}
  async use(opts: MiddlewareOptions<Context>): Promise<MiddlewareResponse> {
      const { req, next } = opts;
      const session = await this.authService.getSession({ req });

      if(session == null) {
        throw new TRPCError("No session found.", "UNAUTHORIZED");
      }

      return next({
        ctx: {
          auth: {
            userId: session.user.id
          }
        }
      })
  }
}
```
  </Tab>
  <Tab value="Generated Interface">
```typescript title="nestjs-trpc-v2/types"
export interface AuthMiddlewareContext extends Context {
  auth: {
    userId: string;
  }
}
```
  </Tab>
</Tabs>

#### Dependency injection
UseMiddlewares fully supports Dependency Injection. Just as with NestJS middlewares and guards, they are able to inject dependencies that are available within the same module. As usual, this is done through the `constructor`.